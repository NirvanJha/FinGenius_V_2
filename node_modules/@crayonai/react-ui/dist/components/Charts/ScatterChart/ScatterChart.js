import { jsx as _jsx, jsxs as _jsxs } from "react/jsx-runtime";
import clsx from "clsx";
import { useEffect, useMemo, useRef, useState } from "react";
import { Cell, ScatterChart as RechartsScatterChart, Scatter, XAxis, YAxis } from "recharts";
import { useId } from "../../../polyfills";
import { ChartContainer, ChartTooltip } from "../Charts";
import { SideBarTooltipProvider } from "../context/SideBarTooltipContext";
import { useYAxisLabelWidth } from "../hooks";
import { CustomTooltipContent, DefaultLegend, gridCartesianGrid, SideBarTooltip, SVGXAxisTick, YAxisTick, } from "../shared";
import { get2dChartConfig, getLegendItems } from "../utils/dataUtils";
import { useChartPalette } from "../utils/PalletUtils";
import { numberTickFormatter } from "../utils/styleUtils";
import ScatterDot from "./components/ScatterDot";
import { calculateScatterDomain, getScatterDatasets, transformScatterData, } from "./utils/ScatterChartUtils";
const DEFAULT_CHART_HEIGHT = 296;
const X_AXIS_HEIGHT = 40;
export const ScatterChart = ({ data, xAxisDataKey = "x", yAxisDataKey = "y", theme = "ocean", customPalette, grid = true, xAxisLabel, yAxisLabel, legend = true, isAnimationActive = false, className, height, width, shape = "circle", }) => {
    const datasets = useMemo(() => {
        return getScatterDatasets(data);
    }, [data]);
    const colors = useChartPalette({
        chartThemeName: theme,
        customPalette,
        themePaletteName: "lineChartPalette",
        dataLength: datasets.length,
    });
    const transformedData = useMemo(() => {
        if (!data || !Array.isArray(data)) {
            return [];
        }
        return transformScatterData(data, datasets, colors);
    }, [data, datasets, colors]);
    const { yAxisWidth, setLabelWidth } = useYAxisLabelWidth(transformedData, [yAxisDataKey]);
    const chartConfig = useMemo(() => {
        return get2dChartConfig(datasets, colors, datasets.reduce((acc, key) => ({ ...acc, [key]: key }), {}), undefined);
    }, [datasets, colors]);
    const chartWrapperRef = useRef(null);
    const legendContainerRef = useRef(null);
    const xAxisContainerRef = useRef(null);
    const [containerWidth, setContainerWidth] = useState(0);
    const [isSideBarTooltipOpen, setIsSideBarTooltipOpen] = useState(false);
    const [isLegendExpanded, setIsLegendExpanded] = useState(false);
    const [sideBarTooltipData, setSideBarTooltipData] = useState({
        title: "",
        values: [],
    });
    const chartWidth = useMemo(() => {
        if (!containerWidth) {
            return undefined;
        }
        return containerWidth - yAxisWidth;
    }, [containerWidth, yAxisWidth]);
    const chartHeight = useMemo(() => {
        if (!chartWrapperRef.current) {
            return 0;
        }
        const legendHeight = legendContainerRef.current?.offsetHeight ?? 0;
        const xAxisHeight = xAxisContainerRef.current?.offsetHeight ?? 0;
        if (typeof height === "number") {
            return height - legendHeight - xAxisHeight;
        }
        if (typeof height === "string" && height.endsWith("px")) {
            const numericHeight = parseInt(height, 10);
            if (!isNaN(numericHeight)) {
                return numericHeight - legendHeight - xAxisHeight;
            }
        }
        if (!height) {
            return DEFAULT_CHART_HEIGHT;
        }
        return chartWrapperRef.current.offsetHeight - legendHeight - xAxisHeight;
    }, [containerWidth, height]);
    const isFixedNumericHeight = useMemo(() => {
        if (typeof height === "number")
            return true;
        if (typeof height === "string" && height.endsWith("px"))
            return true;
        return false;
    }, [height]);
    // Calculate domains for x and y axes
    const xDomain = useMemo(() => {
        return calculateScatterDomain(data, xAxisDataKey);
    }, [data, xAxisDataKey]);
    const yDomain = useMemo(() => {
        return calculateScatterDomain(data, yAxisDataKey);
    }, [data, yAxisDataKey]);
    const renderDotShape = useMemo(() => {
        return (props) => {
            return _jsx(ScatterDot, { ...props, variant: shape });
        };
    }, [shape]);
    useEffect(() => {
        const chartElement = chartWrapperRef.current;
        if (!chartElement) {
            return;
        }
        const resizeObserver = new ResizeObserver((entries) => {
            for (const entry of entries) {
                if (entry.target === chartElement) {
                    setContainerWidth(entry.contentRect.width);
                }
            }
        });
        resizeObserver.observe(chartElement);
        return () => {
            resizeObserver.disconnect();
        };
    }, []);
    useEffect(() => {
        setIsSideBarTooltipOpen(false);
        setIsLegendExpanded(false);
    }, [datasets]);
    const legendItems = useMemo(() => {
        return getLegendItems(datasets, colors);
    }, [datasets, colors]);
    const id = useId();
    const xAxis = useMemo(() => {
        return (_jsx("div", { className: "crayon-scatter-chart-x-axis-container", ref: xAxisContainerRef, children: _jsx(ChartContainer, { config: chartConfig, style: { width: "100%", height: X_AXIS_HEIGHT }, rechartsProps: {
                    height: X_AXIS_HEIGHT,
                }, children: _jsxs(RechartsScatterChart, { data: transformedData, margin: {
                        top: 10,
                        bottom: 0,
                        left: yAxisWidth,
                        right: 0,
                    }, children: [_jsx(XAxis, { type: "number", height: X_AXIS_HEIGHT, name: xAxisLabel, tickLine: false, axisLine: false, tickFormatter: numberTickFormatter, tick: _jsx(SVGXAxisTick, { dy: 10 }), domain: xDomain, dataKey: xAxisDataKey }), _jsx(Scatter, { data: transformedData, fill: "transparent", isAnimationActive: isAnimationActive, shape: "circle" })] }, `x-axis-scatter-chart-${id}`) }) }));
    }, [
        chartConfig,
        transformedData,
        id,
        xDomain,
        xAxisDataKey,
        isAnimationActive,
        xAxisLabel,
        yAxisWidth,
    ]);
    const yAxis = useMemo(() => {
        return (_jsx("div", { className: "crayon-scatter-chart-y-axis-container", style: { height: chartHeight + 20 }, children: _jsxs(RechartsScatterChart, { width: yAxisWidth, height: chartHeight + 10, data: transformedData, margin: {
                    top: 10,
                    bottom: 12,
                    left: 0,
                    right: 0,
                }, children: [_jsx(YAxis, { type: "number", width: yAxisWidth, dataKey: yAxisDataKey, name: yAxisLabel, domain: yDomain, tickLine: false, axisLine: false, tick: _jsx(YAxisTick, { setLabelWidth: setLabelWidth }), tickFormatter: numberTickFormatter }), _jsx(Scatter, { data: transformedData, fill: "transparent", isAnimationActive: isAnimationActive, shape: "circle" })] }, `y-axis-scatter-chart-${id}`) }));
    }, [
        transformedData,
        id,
        yAxisWidth,
        chartHeight,
        yDomain,
        yAxisDataKey,
        yAxisLabel,
        isAnimationActive,
        setLabelWidth,
    ]);
    return (_jsx(SideBarTooltipProvider, { isSideBarTooltipOpen: isSideBarTooltipOpen, setIsSideBarTooltipOpen: setIsSideBarTooltipOpen, data: sideBarTooltipData, setData: setSideBarTooltipData, children: _jsxs("div", { className: clsx("crayon-scatter-chart-container", className), style: {
                width: typeof width === "number" ? `${width}px` : width || "100%",
                height: isFixedNumericHeight ? "auto" : height || "100%",
            }, ref: chartWrapperRef, children: [_jsxs("div", { className: "crayon-scatter-chart-container-inner", children: [yAxis, _jsx("div", { className: "crayon-scatter-chart-main-and-x-axis-container", style: { width: chartWidth }, children: _jsx("div", { className: "crayon-scatter-chart-main-container", style: {
                                    width: "100%",
                                    height: chartHeight,
                                }, children: _jsx(ChartContainer, { config: chartConfig, style: {
                                        width: "100%",
                                        height: "100%",
                                        aspectRatio: 0,
                                    }, rechartsProps: {
                                        width: "100%",
                                        height: "100%",
                                    }, children: _jsxs(RechartsScatterChart, { margin: {
                                            top: 10,
                                            right: 2,
                                            bottom: 2,
                                            left: 2,
                                        }, children: [grid && gridCartesianGrid({ horizontal: true, vertical: true }), _jsx(XAxis, { type: "number", name: xAxisLabel, domain: xDomain, dataKey: xAxisDataKey, hide: true }), _jsx(YAxis, { type: "number", dataKey: yAxisDataKey, name: yAxisLabel, domain: yDomain, hide: true }), _jsx(ChartTooltip, { content: _jsx(CustomTooltipContent, { parentRef: chartWrapperRef, hideIndicator: true, labelKey: "dataset" }), offset: 15 }), _jsx(Scatter, { data: transformedData, shape: renderDotShape, isAnimationActive: isAnimationActive, children: transformedData.map((entry, index) => (_jsx(Cell, { fill: entry["color"] }, `cell-${index}`))) }, `scatter-${id}`)] }, `scatter-chart-${id}`) }) }) }), xAxis, isSideBarTooltipOpen && chartHeight > 0 && _jsx(SideBarTooltip, { height: chartHeight })] }), _jsx("div", { className: "crayon-scatter-chart-legend-container", ref: legendContainerRef, children: legend && (_jsx(DefaultLegend, { items: legendItems, yAxisLabel: yAxisLabel, xAxisLabel: xAxisLabel, containerWidth: containerWidth, isExpanded: isLegendExpanded, setIsExpanded: setIsLegendExpanded })) })] }) }));
};
//# sourceMappingURL=ScatterChart.js.map