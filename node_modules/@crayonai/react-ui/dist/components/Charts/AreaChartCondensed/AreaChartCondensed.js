import { jsx as _jsx, jsxs as _jsxs } from "react/jsx-runtime";
import clsx from "clsx";
import React, { useEffect, useMemo, useRef, useState } from "react";
import { Area, AreaChart as RechartsAreaChart, XAxis, YAxis } from "recharts";
import { useId } from "../../../polyfills";
import { ChartContainer, ChartTooltip } from "../Charts";
import { DEFAULT_X_AXIS_HEIGHT, X_AXIS_PADDING } from "../constants";
import { SideBarTooltipProvider } from "../context/SideBarTooltipContext";
import { useAutoAngleCalculation, useMaxLabelWidth, useTransformedKeys, useYAxisLabelWidth, } from "../hooks";
import { ActiveDot, cartesianGrid, CustomTooltipContent, DefaultLegend, SVGXAxisTick, YAxisTick, } from "../shared";
import { LabelTooltipProvider } from "../shared/LabelTooltip/LabelTooltip";
import { getLineType } from "../utils/AreaAndLine/common";
import { get2dChartConfig, getDataKeys, getLegendItems } from "../utils/dataUtils";
import { useChartPalette } from "../utils/PalletUtils";
const CHART_HEIGHT = 296;
const CHART_CONTAINER_BOTTOM_MARGIN = 10;
const AreaChartCondensedComponent = ({ data, categoryKey, theme = "ocean", customPalette, variant: areaChartVariant = "natural", tickVariant = "singleLine", grid = true, icons = {}, isAnimationActive = false, showYAxis = true, xAxisLabel, yAxisLabel, legend = true, className, height = CHART_HEIGHT, width, }) => {
    const dataKeys = useMemo(() => {
        return getDataKeys(data, categoryKey);
    }, [data, categoryKey]);
    const variant = getLineType(areaChartVariant);
    const { yAxisWidth, setLabelWidth } = useYAxisLabelWidth(data, dataKeys);
    const maxLabelWidth = useMaxLabelWidth(data, categoryKey);
    const chartContainerRef = useRef(null);
    const [chartContainerWidth, setChartContainerWidth] = useState(0);
    const widthOfData = useMemo(() => {
        if (data.length === 0) {
            return 0;
        }
        return chartContainerWidth / data.length;
    }, [chartContainerWidth, data]);
    const { angle: calculatedAngle, height: xAxisHeight } = useAutoAngleCalculation(maxLabelWidth, tickVariant === "angled", 
    // if the max label width is less than 100px, then we use the width of the data to calculate the angle, gives better results for small datasets
    maxLabelWidth < 100 ? widthOfData : undefined);
    const isAngled = useMemo(() => {
        return calculatedAngle !== 0;
    }, [calculatedAngle]);
    const effectiveHeight = useMemo(() => {
        if (tickVariant === "angled") {
            return xAxisHeight + height;
        }
        return height + DEFAULT_X_AXIS_HEIGHT;
    }, [height, xAxisHeight, tickVariant]);
    const transformedKeys = useTransformedKeys(dataKeys);
    const colors = useChartPalette({
        chartThemeName: theme,
        customPalette,
        themePaletteName: "areaChartPalette",
        dataLength: dataKeys.length,
    });
    const chartConfig = useMemo(() => {
        return get2dChartConfig(dataKeys, colors, transformedKeys, undefined, icons);
    }, [dataKeys, icons, colors, transformedKeys]);
    const id = useId();
    const gradientID = useMemo(() => `area-chart-condensed-gradient-${id}`, [id]);
    const chartMargin = useMemo(() => ({
        top: 10,
        right: 10,
        bottom: CHART_CONTAINER_BOTTOM_MARGIN,
        left: showYAxis ? 10 : 0,
    }), [showYAxis]);
    const containerRef = useRef(null);
    const [containerWidth, setContainerWidth] = useState(0);
    const [isSideBarTooltipOpen, setIsSideBarTooltipOpen] = useState(false);
    const [sideBarTooltipData, setSideBarTooltipData] = useState({
        title: "",
        values: [],
    });
    const [isLegendExpanded, setIsLegendExpanded] = useState(false);
    // Use provided width or observed width
    const effectiveWidth = useMemo(() => {
        return width ?? containerWidth;
    }, [width, containerWidth]);
    // Observe container width for legend
    useEffect(() => {
        // Only set up ResizeObserver if width is not provided
        if (width || !containerRef.current || !chartContainerRef.current) {
            return () => { };
        }
        const resizeObserver = new ResizeObserver((entries) => {
            // there is only one entry in the entries array because we are observing the chart container
            for (const entry of entries) {
                if (entry.target === containerRef.current) {
                    setContainerWidth(entry.contentRect.width);
                }
                if (entry.target === chartContainerRef.current) {
                    setChartContainerWidth(entry.contentRect.width);
                }
            }
        });
        resizeObserver.observe(containerRef.current);
        resizeObserver.observe(chartContainerRef.current);
        return () => {
            resizeObserver.disconnect();
        };
    }, [width]);
    useEffect(() => {
        setIsLegendExpanded(false);
    }, [dataKeys]);
    // Memoize legend items creation
    const legendItems = useMemo(() => {
        if (!legend) {
            return [];
        }
        return getLegendItems(dataKeys, colors, icons);
    }, [dataKeys, colors, icons, legend]);
    const yAxis = useMemo(() => {
        if (!showYAxis) {
            return null;
        }
        return (_jsx("div", { className: "crayon-area-chart-condensed-y-axis-container", children: _jsxs(RechartsAreaChart, { width: yAxisWidth, height: effectiveHeight, data: data, margin: {
                    top: chartMargin.top,
                    bottom: xAxisHeight + chartMargin.bottom, // this is required to give space for x-axis
                    left: 0,
                    right: 0,
                }, children: [_jsx(YAxis, { width: yAxisWidth, tickLine: false, axisLine: false, tick: _jsx(YAxisTick, { setLabelWidth: setLabelWidth }) }), dataKeys.map((key) => {
                        return (_jsx(Area, { dataKey: key, fill: "transparent", stroke: "transparent", stackId: "a", isAnimationActive: false }, `yaxis-area-chart-condensed-${key}`));
                    })] }, `y-axis-area-chart-condensed-${id}`) }));
    }, [
        showYAxis,
        effectiveHeight,
        data,
        dataKeys,
        id,
        yAxisWidth,
        chartMargin,
        xAxisHeight,
        setLabelWidth,
    ]);
    return (_jsx(LabelTooltipProvider, { children: _jsx(SideBarTooltipProvider, { isSideBarTooltipOpen: isSideBarTooltipOpen, setIsSideBarTooltipOpen: setIsSideBarTooltipOpen, data: sideBarTooltipData, setData: setSideBarTooltipData, children: _jsxs("div", { className: clsx("crayon-area-chart-condensed-container", className), style: {
                    width: width ? `${width}px` : undefined,
                }, children: [yAxisLabel && (_jsx("div", { className: "crayon-area-chart-condensed-y-axis-label", children: yAxisLabel })), _jsxs("div", { className: "crayon-area-chart-condensed-container-inner", ref: containerRef, children: [yAxis, _jsx("div", { className: "crayon-area-chart-condensed", ref: chartContainerRef, children: _jsx(ChartContainer, { config: chartConfig, style: { width: "100%", height: effectiveHeight }, rechartsProps: {
                                        width: "100%",
                                        height: "100%",
                                    }, children: _jsxs(RechartsAreaChart, { accessibilityLayer: true, data: data, margin: chartMargin, children: [grid && cartesianGrid(), _jsx(XAxis, { dataKey: categoryKey, tickLine: false, axisLine: false, textAnchor: isAngled ? "end" : "middle", interval: "preserveStartEnd", minTickGap: 5, height: xAxisHeight, tick: _jsx(SVGXAxisTick, {}), angle: calculatedAngle, orientation: "bottom", padding: {
                                                    left: X_AXIS_PADDING,
                                                    right: X_AXIS_PADDING,
                                                } }), _jsx(ChartTooltip, { content: _jsx(CustomTooltipContent, { parentRef: containerRef }), offset: 10 }), dataKeys.map((key) => {
                                                const transformedKey = transformedKeys[key];
                                                const color = `var(--color-${transformedKey})`;
                                                return (_jsx("defs", { children: _jsxs("linearGradient", { id: `${gradientID}-${transformedKey}`, x1: "0", y1: "0", x2: "0", y2: "1", children: [_jsx("stop", { offset: "5%", stopColor: color, stopOpacity: 0.6 }), _jsx("stop", { offset: "95%", stopColor: color, stopOpacity: 0 })] }) }, `gradient-${transformedKey}`));
                                            }), dataKeys.map((key) => {
                                                const transformedKey = transformedKeys[key];
                                                const color = `var(--color-${transformedKey})`;
                                                return (_jsx(Area, { dataKey: key, type: variant, stroke: color, fill: `url(#${gradientID}-${transformedKey})`, fillOpacity: 1, stackId: "a", activeDot: _jsx(ActiveDot, {}, `active-dot-${key}-${id}`), dot: false, isAnimationActive: isAnimationActive }, `area-${key}`));
                                            })] }, `area-chart-condensed-${id}`) }) })] }), xAxisLabel && (_jsx("div", { className: "crayon-area-chart-condensed-x-axis-label", children: xAxisLabel })), legend && (_jsx(DefaultLegend, { items: legendItems, containerWidth: effectiveWidth, isExpanded: isLegendExpanded, setIsExpanded: setIsLegendExpanded }))] }) }) }));
};
// Added React.memo for performance optimization to avoid unnecessary re-renders
export const AreaChartCondensed = React.memo(AreaChartCondensedComponent);
//# sourceMappingURL=AreaChartCondensed.js.map